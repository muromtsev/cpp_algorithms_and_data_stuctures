## Параметры и аргументы функций
Существует 3 основных способа передачи аргументов в функцию:
 - передача по значению;
 - передача по ссылке;
 - передача по адресу.
 
### Передача по значению
По умолчанию, аргументы в C++ передаются по значению. Когда аргумент передается по значению, то его значение копируется в параметр функции.
```cpp
#include <iostream>

void boo(int y)
{
	std::cout << "y = " << y << std::endl;
}
int main()
{
	boo(7); // 1-й вызов
	int x = 8;
	boo(x); // 2-й вызов 
	boo(x + 2); // 3-й вызов
	return 0;
}
```
#### Плюсы и минусы передачи по значению
- Аргументы, переданные по значению, могут быть переменными (например, x), литералами (например, 8), выражениями (например, x + 2 ), структурами, классами или перечислителями (т.е. почти всем, чем угодно).
- Аргументы никогда не изменяются функцией, в которую передаются, что предотвращает возникновение побочных эффектов.
#### Минусы передачи по значению:
- Копирование структур и классов может привести к значительному снижению производительности (особенно, когда функция вызывается много раз).
#### Когда использовать передачу по значению:
- При передаче фундаментальных типов данных и перечислителей, когда предполагается, что функция не должна изменять аргумент.
#### Когда не использовать передачу по значению:
- При передаче массивов, структур и классов.

В большинстве случаев, передача по значению — это наилучший способ передачи
аргументов фундаментальных типов данных, когда функция не должна изменять
исходные значения. Передача по значению является гибкой и безопасной, а в
случае фундаментальных типов данных еще и эффективной.

### Передача по ссылке

При передаче переменной по ссылке нужно просто объявить параметры функции
как ссылки, а не как обычные переменные:
```cpp
void func(int &x) // x - это переменная-ссылка
{
	x = x + 1;
}
```
Поскольку ссылка на переменную обрабатывается точно так же, как и сама переменная, то любые изменения, внесенные в ссылку, приведут к изменениям исходного значения аргумента! В следующем примере это хорошо проиллюстрировано:
```cpp
#include <iostream>

void boo(int &value)
{
	value = 7;
}
int main()
{
	int value = 6;
	std::cout << "value = " << value << '\n';
	boo(value);
	std::cout << "value = " << value << '\n';
	return 0;
}
```
Результат выполнения программы:
`value = 6`
`value = 7`

#### Возврат сразу нескольких значений
Иногда нам может понадобиться, чтобы функция возвращала сразу несколько
значений. Однако оператор return позволяет функции иметь только одно
возвращаемое значение. Одним из способов возврата сразу нескольких значений
является использование ссылок в качестве параметров:
```cpp
#include <iostream>
#include <math.h> // для sin() и cos()

void getSinCos(double degrees, double &sinOut, double &cosOut)
{
	// sin() и cos() принимают радианы, а не градусы, поэтому необходима конвертация
	const double pi = 3.14159265358979323846; // значение Пи
	double radians = degrees * pi / 180.0;
	sinOut = sin(radians);
	cosOut = cos(radians);
}

int main()
{
	double sin(0.0);
	double cos(0.0);
	// Функция getSinCos() возвратит sin и cos в переменные sin и cos
	getSinCos(30.0, sin, cos);

	std::cout << "The sin is " << sin << '\n';
	std::cout << "The cos is " << cos << '\n';
	return 0;
}
```
Эта функция принимает один параметр (передача по значению) в качестве входных
данных и «возвращает» два параметра (передача по ссылке) в качестве выходных
данных. Параметры, которые используются только для возврата значений обратно в
caller, называются параметрами вывода. Они дают понять caller-у, что значения
исходных переменных, переданных в функцию, не столь значительны, так как мы
ожидаем, что эти переменные будут перезаписаны.
#### Передача по константной ссылке
Когда мы знаем, что функция не должна изменять значение аргумента, но не хотим использовать передачу по значению, то лучшим решением будет использовать передачу по константной ссылке.
Запустив следующий фрагмент кода, мы получим ошибку компиляции:
```cpp
void boo(const int &y) // y - это константная ссылка
{
	y = 8; // ошибка компиляции: константная ссылка не может изменить свое же значение!
}
```
Использование const полезно по нескольким причинам:
- Мы получаем гарантию от компилятора, что значения, которые не должны
быть изменены — не изменятся (компилятор выдаст ошибку, если мы
попытаемся сделать нечто подобное тому, что было в вышеприведенном
примере).
- Программист, видя const, понимает, что функция не изменит значение
аргумента. Это может помочь при отладке программы.
- Мы не можем передать константный аргумент в неконстантную ссылку-
параметр. Использование константного параметра гарантирует, что мы
сможем передавать как неконстантные, так и константные аргументы в
функцию.
- Константные ссылки могут принимать любые типы аргументов, включая l-
values, константные l-values и r-values.

*`Правило: При передаче аргументов по ссылке всегда используйте константные
ссылки, если вам не нужно, чтобы функция изменяла значения аргументов.`*
#### Плюсы и минусы передачи по ссылке
#### Плюсы передачи по ссылке:
- Ссылки позволяют функции изменять значение аргумента, что иногда
полезно. В противном случае, для гарантии того, что функция не изменит
значение аргумента, нужно использовать константные ссылки.
- Поскольку при передаче по ссылке копирования аргументов не происходит,
то этот способ гораздо эффективнее и быстрее передачи по значению,
особенно при работе с большими структурами или классами.
- Ссылки могут использоваться для возврата сразу нескольких значений из
функции (через параметры вывода).
#### Минусы передачи по ссылке:
- Трудно определить, является ли параметр, переданный по неконстантной
ссылке, параметром ввода, вывода или того и другого одновременно.
Разумное использование const и суффикса Out для внешних переменных
решает эту проблему.
- По вызову функции невозможно определить, будет аргумент изменен
функцией или нет. Аргумент, переданный по значению или по ссылке,
выглядит одинаково. Мы можем определить способ передачи аргумента
только просмотрев объявление функции. Это может привести к ситуации,
когда программист не сразу поймет, что функция изменяет значение
аргумента.
#### Когда использовать передачу по ссылке:
- при передаче структур или классов (используйте const, если нужно только для
чтения);
- когда нужно, чтобы функция изменяла значение аргумента.
#### Когда не использовать передачу по ссылке:
- при передаче фундаментальных типов данных (используйте передачу по
значению);
- при передаче обычных массивов (используйте передачу по адресу).
### Передача по адресу
__Передача аргументов по адресу__ — это передача адреса переменной-аргумента (а
не исходной переменной). Поскольку аргумент является адресом, то параметром
функции должен быть указатель. Затем функция сможет разыменовать этот
указатель для доступа или изменения исходного значения. Вот пример функции,
которая принимает параметр, передаваемый по адресу:
```cpp
#include <iostream>

void boo(int *ptr)
{
	*ptr = 7;
}

int main()
{
	int value = 4;
	std::cout << "value = " << value << '\n';
	boo(&value);
	std::cout << "value = " << value << '\n';
	return 0;
}
```
Результат выполнения программы:
`value = 4`
`value = 7`
#### Передача по константному адресу
Когда вы передаете указатель в функцию по адресу, то значение этого указателя (адрес, на который он указывает) копируется из аргумента в параметр функции. Другими словами, он передается по значению! Если изменить значение параметра функции, то изменится только копия, исходный указатель-аргумент не будет изменен. 
Например:
```cpp
#include <iostream>

void setToNull(int *tempPtr)
{
	// Мы присваиваем tempPtr другое значение (мы не изменяем значение, на которое указывает tempPtr)
	tempPtr = nullptr; // используйте 0, если не поддерживается C++11
}

int main()
{
	// Сначала мы присваиваем ptr адрес six, т.е. *ptr = 6
	int six = 6;
	int *ptr = &six;

	// Здесь выведется 6
	std::cout << *ptr << "\n";

	// tempPtr получит копию ptr
	setToNull(ptr);
	// ptr до сих пор указывает на переменную six!

	// Здесь выведется 6

	if (ptr)
		std::cout << *ptr << "\n";
	else
		std::cout << " ptr is null";
	return 0;
}
```
В tempPtr копируется адрес указателя ptr. Несмотря на то, что мы изменили
tempPtr на нулевой указатель (присвоили ему nullptr), это никак не повлияло на
значение, на которое указывает ptr. Следовательно, результат выполнения
программы:
`6`
`6`
Обратите внимание, хотя сам адрес передается по значению, вы все равно можете
разыменовать его для изменения значения исходного аргумента. Запутано? Давайте
проясним:
- При передаче аргумента по адресу в переменную-параметр функции
копируется адрес из аргумента. В этот момент параметр функции и аргумент
указывают на одно и то же значение.
- Если параметр функции затем разыменовать для изменения исходного
значения, то это приведет к изменению значения, на которое указывает
аргумент, поскольку параметр функции и аргумент указывают на одно и то же
значение!
- Если параметру функции присвоить другой адрес, то это никак не повлияет на
аргумент, поскольку параметр функции является копией, а изменение копии
не приводит к изменению оригинала. После изменения адреса параметра
функции, параметр функции и аргумент будут указывать на разные значения,
поэтому разыменование параметра и дальнейшее его изменение никак не
повлияют на значение, на которое указывает аргумент.

В следующей программе это всё хорошо проиллюстрировано:
```cpp
#include <iostream>

void setToSeven(int *tempPtr)
{
	*tempPtr = 7; // мы изменяем значение, на которое указывает tempPtr (и ptr тоже)
}

int main()
{
	// Сначала мы присваиваем ptr адрес six, т.е. *ptr = 6
	int six = 6;
	int *ptr = &six;
	
	// Здесь выведется 6
	std::cout << *ptr << "\n";

	// tempPtr получит копию ptr
	setToSeven(ptr);
	// tempPtr изменил значение, на которое указывал, на 7
	// Здесь выведется 7
	if (ptr)
		std::cout << *ptr << "\n";
	else
		std::cout << " ptr is null";
	return 0;
}
```
Результат выполнения программы:
`6`
`7`
#### Передача адресов по ссылке
Следует вопрос: «А что, если мы хотим изменить адрес, на который указывает
аргумент, внутри функции?». Оказывается, это можно сделать очень легко. Вы
можете просто передать адрес по ссылке. Синтаксис ссылки на указатель может
показаться немного странным, но все же:
```cpp
#include <iostream>

// tempPtr теперь является ссылкой на указатель, поэтому любые изменения tempPtr приведут и к изменениям исходного аргумента!
void setToNull(int *&tempPtr)
{
	tempPtr = nullptr; // используйте 0, если не поддерживается C++11
}

int main()
{
	// Сначала мы присваиваем ptr адрес six, т.е. *ptr = 6
	int six = 6;
	int *ptr = &six;
	
	// Здесь выведется 6
	std::cout << *ptr;
	// tempPtr является ссылкой на ptr
	setToNull(ptr);
	// ptr было присвоено значение nullptr!
	if (ptr)
		std::cout << *ptr;
	else
		std::cout << " ptr is null";
return 0;
}
```
Результат выполнения программы:
`6 ptr is null`
Наконец, наша функция setToNull() действительно изменила значение ptr с &six
на nullptr!
#### Существует только передача по значению
Теперь, когда вы понимаете основные различия между передачей по ссылке, по
адресу и по значению, давайте немного поговорим о том, что находится "под
капотом".
На уроке о ссылках мы упоминали, что ссылки на самом деле реализуются с
помощью указателей. Это означает, что передача по ссылке является просто
передачей по адресу. И чуть выше мы говорили, что передача по адресу на самом
деле является передачей адреса по значению! Из этого следует, что C++
действительно передает всё по значению!
#### Плюсы и минусы передачи по адресу
#### Плюсы передачи по адресу:
- Передача по адресу позволяет функции изменить значение аргумента, что
иногда полезно. В противном случае, используем const для гарантии того, что
функция не изменит аргумент.
- Поскольку копирования аргументов не происходит, то скорость передачи по
адресу достаточно высокая, даже если передавать большие структуры или
классы.
- Мы можем вернуть сразу несколько значений из функции, используя
параметры вывода.
#### Минусы передачи по адресу:
- Все указатели нужно проверять, не являются ли они нулевыми. Попытка
разыменовать нулевой указатель приведет к сбою в программе.
- Поскольку разыменование указателя выполняется медленнее, чем доступ к
значению напрямую, то доступ к аргументам, переданным по адресу,
выполняется также медленнее, чем доступ к аргументам, переданным по
значению.
#### Когда использовать передачу по адресу:
- при передаче обычных массивов (если нет никаких проблем с тем, что
массивы распадаются в указатели при передаче).
Когда не использовать передачу по адресу:
- при передаче структур или классов (используйте передачу по ссылке);
- при передаче фундаментальных типов данных (используйте передачу по
значению).

Как вы можете видеть сами, передача по адресу и по ссылке имеют почти
одинаковые преимущества и недостатки. Поскольку передача по ссылке обычно
безопаснее, чем передача по адресу, то в большинстве случаев предпочтительнее
использовать передачу по ссылке.

*`Правило: Используйте передачу по ссылке, вместо передачи по адресу, когда это
возможно.`*

### Возврат значений по ссылке, по адресу и по значению

#### Возврат по значению
__Возврат по значению__ — это самый простой и безопасный тип возврата. При
возврате по значению, копия возвращаемого значения передается обратно в caller.
Как и в случае с передачей по значению, вы можете возвращать литералы
(например, 7), переменные (например, x) или выражения (например, x + 2), что
делает этот способ очень гибким.
```cpp
int doubleValue(int a)
{
	int value = a * 3;
	return value; // копия value возвращается здесь
} // value выходит из области видимости здесь
```
Возврат по значению идеально подходит для возврата переменных, которые были
объявлены внутри функции, или для возврата аргументов функции, которые были
переданы по значению. Однако, подобно передаче по значению, возврат по
значению медленный при работе со структурами и классами.
#### Когда использовать возврат по значению:
- при возврате переменных, которые были объявлены внутри функции;
- при возврате аргументов функции, которые были переданы в функцию по
значению.
#### Когда не использовать возврат по значению:
- при возврате стандартных массивов или указателей (используйте возврат по
адресу);
- при возврате больших структур или классов (используйте возврат по ссылке).
#### Возврат по адресу
__Возврат по адресу__ — это возврат адреса переменной обратно в caller. Подобно
передаче по адресу, возврат по адресу может возвращать только адрес
переменной. Литералы и выражения возвращать нельзя, так как они не имеют
адресов. Поскольку при возврате по адресу просто копируется адрес из функции в
caller, то этот процесс также очень быстрый.
Возврат по адресу часто используется для возврата динамически выделенной
памяти обратно в caller:
```cpp
int* allocateArray(int size)
{
	return new int[size];
}

int main()
{
	int *array = allocateArray(20);
	
	// Делаем что-нибудь с array

	delete[] array;
	return 0;
}
```
#### Когда использовать возврат по адресу:
- при возврате динамически выделенной памяти;
- при возврате аргументов функции, которые были переданы по адресу.
#### Когда не использовать возврат по адресу:
- при возврате переменных, которые были объявлены внутри функции
(используйте возврат по значению);
- при возврате большой структуры или класса, который был передан по ссылке
(используйте возврат по ссылке).
#### Возврат по ссылке
Подобно передаче по ссылке, значения, возвращаемые по ссылке, должны быть
переменными (вы не сможете вернуть ссылку на литерал или выражение). При
возврате по ссылке в caller возвращается ссылка на переменную. Затем caller может
её использовать для продолжения изменения переменной, что может быть иногда
полезно. Этот способ также очень быстрый и при возврате больших структур или
классов.
Возврат по ссылке обычно используется для возврата аргументов, переданных в
функцию по ссылке. В следующем примере мы возвращаем (по ссылке) элемент
массива, который был передан в функцию по ссылке:
```cpp
#include <iostream>
#include <array>
// Возвращаем ссылку на элемент массива по индексу index
int& getElement(std::array<int, 20> &array, int index)
{
	// Мы знаем, что array[index] не уничтожится, когда мы будем возвращать данные в caller (так как caller сам передал этот array в функцию!)
// Так что здесь не должно быть никаких проблем с возвратом по ссылке
	return array[index];
}

int main()
{
	std::array<int, 20> array;

	// Присваиваем элементу массива под индексом 15 значение 7
	getElement(array, 15) = 7;

	std::cout << array[15] << '\n';
	return 0;
}
```
Результат выполнения программы:
`7`

#### Когда использовать возврат по ссылке:
- при возврате ссылки-параметра;
- при возврате элемента массива, который был передан в функцию;
- при возврате большой структуры или класса, который не уничтожается в
конце функции (например, тот, который был передан в функцию).
#### Когда не использовать возврат по ссылке:
- при возврате переменных, которые были объявлены внутри функции
(используйте возврат по значению);
- при возврате стандартного массива или значения указателя (используйте
возврат по адресу).
