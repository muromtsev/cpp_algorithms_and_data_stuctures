### Перечисляемые типы
**Перечисление** (или "перечисляемый тип") — это тип данных, где любое значение (или "перечислитель") определяется как символьная константа. 
```cpp
// Объявляем новое перечисление Colors
enum Colors
{
// Ниже находятся перечислители - все возможные значения этого типа данных
// Каждый перечислитель отделяется запятой (НЕ точкой с запятой)
	COLOR_RED,
	COLOR_BROWN,
	COLOR_GRAY,
	COLOR_WHITE,
	COLOR_PINK,
	COLOR_ORANGE,
	COLOR_BLUE,
	COLOR_PURPLE, // о конечной запятой читайте ниже
}; // однако сам enum должен заканчиваться точкой с запятой

 // Определяем несколько переменных перечисляемого типа Colors
Colors paint = COLOR_RED;
Colors house(COLOR_GRAY);
```
### Значения перечислителей
Каждому перечислителю автоматически присваивается целочисленное значение в зависимости от его позиции в списке перечисления. По умолчанию, первому перечислителю присваивается целое число 0, а каждому следующему — на единицу больше, чем предыдущему:
```cpp
#include <iostream>
enum Colors
{
	COLOR_YELLOW, // присваивается 0
	COLOR_WHITE, // присваивается 1
	COLOR_ORANGE, // присваивается 2
	COLOR_GREEN, // присваивается 3
	COLOR_RED, // присваивается 4
	COLOR_GRAY, // присваивается 5
	COLOR_PURPLE, // присваивается 6
	COLOR_BROWN // присваивается 7
};

int main()
{
	Colors paint(COLOR_RED);
	std::cout << paint;
	return 0;
}
```
Результат выполнения программы:
```4```

### Классы enum

в C++11 добавили классы enum (или "перечисления с областью видимости"), которые добавляют перечислениям, как вы уже могли
понять, локальную область видимости со всеми её правилами. Для создания такого
класса нужно просто добавить ключевое слово class сразу после enum.
```cpp
#include <iostream>

int main()
{
enum class Fruits // добавление "class" к enum определяет перечисление с
// ограниченной областью видимости, вместо стандартного "глобального" перечисления
{
	LEMON, // LEMON находится внутри той же области видимости, что и Fruits
	KIWI
};

enum class Colors
{
	PINK, // PINK находится внутри той же области видимости, что и Colors
	GRAY
};

Fruits fruit = Fruits::LEMON; // примечание: LEMON напрямую не доступен,
//мы должны использовать Fruits::LEMON
Colors color = Colors::PINK; // примечание: PINK напрямую не доступен, мы
//должны использовать Colors::PINK

if (fruit == color) // ошибка компиляции, поскольку компилятор не знает,
//как сравнивать разные типы: Fruits и Colors
	std::cout << "fruit and color are equal\n";
else
	std::cout << "fruit and color are not equal\n";
return 0;
}
```
